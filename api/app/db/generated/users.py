# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.29.0
# source: users.sql
import pydantic
from typing import AsyncIterator, Iterator, Optional

import sqlalchemy
import sqlalchemy.ext.asyncio

from app.db.generated import models


CREATE_USER = """-- name: create_user \\:one
INSERT INTO users (
    username, email, avatar, cover
)
VALUES (
           :p1, :p2, :p3, :p4
       )
RETURNING id, created, modified, username, discriminator, full_username, email, avatar, cover, availability_status
"""


DELETE_USER = """-- name: delete_user \\:one
DELETE
FROM users
WHERE id = :p1
RETURNING id
"""


GET_USER = """-- name: get_user \\:one
SELECT id, created, modified, username, discriminator, full_username, email, avatar, cover, availability_status
FROM users
WHERE id = :p1
"""


LIST_USERS = """-- name: list_users \\:many
SELECT id, created, modified, username, discriminator, full_username, email, avatar, cover, availability_status
FROM users
"""


UPDATE_USER = """-- name: update_user \\:one
UPDATE users
SET username              = COALESCE(:p1, username),
    discriminator         = COALESCE(:p2, discriminator),
    email                 = COALESCE(:p3, email),
    avatar                = COALESCE(:p4, avatar),
    cover                 = COALESCE(:p5, cover),
    "availability_status" = COALESCE(:p6\\:\\:AVAILABILITY_STATUS, "availability_status")
WHERE id = :p7
RETURNING id, created, modified, username, discriminator, full_username, email, avatar, cover, availability_status
"""


class UpdateUserParams(pydantic.BaseModel):
    username: Optional[str]
    discriminator: Optional[int]
    email: Optional[str]
    avatar: Optional[str]
    cover: Optional[str]
    availability_status: Optional[models.AvailabilityStatus]
    id: str


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def create_user(
        self, *, username: str, email: str, avatar: Optional[str], cover: Optional[str]
    ) -> Optional[models.User]:
        row = self._conn.execute(
            sqlalchemy.text(CREATE_USER),
            {
                "p1": username,
                "p2": email,
                "p3": avatar,
                "p4": cover,
            },
        ).first()
        if row is None:
            return None
        return models.User(
            id=row[0],
            created=row[1],
            modified=row[2],
            username=row[3],
            discriminator=row[4],
            full_username=row[5],
            email=row[6],
            avatar=row[7],
            cover=row[8],
            availability_status=row[9],
        )

    def delete_user(self, *, id: str) -> Optional[str]:
        row = self._conn.execute(sqlalchemy.text(DELETE_USER), {"p1": id}).first()
        if row is None:
            return None
        return row[0]

    def get_user(self, *, id: str) -> Optional[models.User]:
        row = self._conn.execute(sqlalchemy.text(GET_USER), {"p1": id}).first()
        if row is None:
            return None
        return models.User(
            id=row[0],
            created=row[1],
            modified=row[2],
            username=row[3],
            discriminator=row[4],
            full_username=row[5],
            email=row[6],
            avatar=row[7],
            cover=row[8],
            availability_status=row[9],
        )

    def list_users(self) -> Iterator[models.User]:
        result = self._conn.execute(sqlalchemy.text(LIST_USERS))
        for row in result:
            yield models.User(
                id=row[0],
                created=row[1],
                modified=row[2],
                username=row[3],
                discriminator=row[4],
                full_username=row[5],
                email=row[6],
                avatar=row[7],
                cover=row[8],
                availability_status=row[9],
            )

    def update_user(self, arg: UpdateUserParams) -> Optional[models.User]:
        row = self._conn.execute(
            sqlalchemy.text(UPDATE_USER),
            {
                "p1": arg.username,
                "p2": arg.discriminator,
                "p3": arg.email,
                "p4": arg.avatar,
                "p5": arg.cover,
                "p6": arg.availability_status,
                "p7": arg.id,
            },
        ).first()
        if row is None:
            return None
        return models.User(
            id=row[0],
            created=row[1],
            modified=row[2],
            username=row[3],
            discriminator=row[4],
            full_username=row[5],
            email=row[6],
            avatar=row[7],
            cover=row[8],
            availability_status=row[9],
        )


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def create_user(
        self, *, username: str, email: str, avatar: Optional[str], cover: Optional[str]
    ) -> Optional[models.User]:
        row = (
            await self._conn.execute(
                sqlalchemy.text(CREATE_USER),
                {
                    "p1": username,
                    "p2": email,
                    "p3": avatar,
                    "p4": cover,
                },
            )
        ).first()
        if row is None:
            return None
        return models.User(
            id=row[0],
            created=row[1],
            modified=row[2],
            username=row[3],
            discriminator=row[4],
            full_username=row[5],
            email=row[6],
            avatar=row[7],
            cover=row[8],
            availability_status=row[9],
        )

    async def delete_user(self, *, id: str) -> Optional[str]:
        row = (
            await self._conn.execute(sqlalchemy.text(DELETE_USER), {"p1": id})
        ).first()
        if row is None:
            return None
        return row[0]

    async def get_user(self, *, id: str) -> Optional[models.User]:
        row = (await self._conn.execute(sqlalchemy.text(GET_USER), {"p1": id})).first()
        if row is None:
            return None
        return models.User(
            id=row[0],
            created=row[1],
            modified=row[2],
            username=row[3],
            discriminator=row[4],
            full_username=row[5],
            email=row[6],
            avatar=row[7],
            cover=row[8],
            availability_status=row[9],
        )

    async def list_users(self) -> AsyncIterator[models.User]:
        result = await self._conn.stream(sqlalchemy.text(LIST_USERS))
        async for row in result:
            yield models.User(
                id=row[0],
                created=row[1],
                modified=row[2],
                username=row[3],
                discriminator=row[4],
                full_username=row[5],
                email=row[6],
                avatar=row[7],
                cover=row[8],
                availability_status=row[9],
            )

    async def update_user(self, arg: UpdateUserParams) -> Optional[models.User]:
        row = (
            await self._conn.execute(
                sqlalchemy.text(UPDATE_USER),
                {
                    "p1": arg.username,
                    "p2": arg.discriminator,
                    "p3": arg.email,
                    "p4": arg.avatar,
                    "p5": arg.cover,
                    "p6": arg.availability_status,
                    "p7": arg.id,
                },
            )
        ).first()
        if row is None:
            return None
        return models.User(
            id=row[0],
            created=row[1],
            modified=row[2],
            username=row[3],
            discriminator=row[4],
            full_username=row[5],
            email=row[6],
            avatar=row[7],
            cover=row[8],
            availability_status=row[9],
        )
